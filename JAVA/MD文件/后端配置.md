## 后端负责人视角的当前优先级

你这个系统的后端成败取决于三件事：并发编排是否可控，流式推送是否可靠可恢复，模型成本与质量是否可治理。我会按“先把底座做稳，再做互怼与花活”的顺序推进。

---

## 1. 采用的框架与技术

### 应用框架

- **Spring Boot 3.x**
    
- **Spring WebFlux** 作为默认 Web 层与编排层
    
    - 目标是把“多 Agent 并发流式输出”表达为可组合的 `Flux<RoundtableEvent>`，天然支持取消、超时、背压。
        

### 实时推送

- **WebSocket + STOMP**（短期最省心）
    
    - 对前端订阅模型友好，能快速做出多卡片并发打字机效果。
        
    - 必须加 `topicId + agentId + seq + eventType`，否则无法做重连补发与乱序修复。
        

### LLM 接入

- **Spring AI** 作为供应商适配层
    
    - 业务层完全不感知 OpenAI DeepSeek Claude 的差异。
        
    - 支持后续做路由，降级，灰度，多模型对比评测。
        

### 稳定性与治理

- **Resilience4j**：超时、重试、熔断、限流
    
- **Micrometer + OpenTelemetry**：指标与链路追踪
    
- **PostgreSQL**：持久化话题、纪要、prompt 版本、审计
    
- **Redis**：短期事件缓存与重连补发窗口，topic 状态机
    

---

## 2. 关键后端能力拆解

### 2.1 圆桌事件协议（必须先定）

后端不应只推 token 字符串，必须推事件，前端才有可控 UI。

**RoundtableEvent 基本字段**

- `topicId`：一次议题的全局 ID
    
- `agentId`
    
- `eventType`：`START | DELTA | SECTION | END | ERROR`
    
- `seq`：单 agent 单调递增
    
- `content`：仅 `DELTA` 需要
    
- `payload`：结构化信息，如摘要、风险清单、行动项、引用
    

意义：你能做断线重连补发，能对输出做质量评测，能对成本做治理。

### 2.2 并发编排（Round 0 稳定优先）

MVP 先实现 Round 0 并发立场稿。

- 每个 Agent 一条 `Flux<RoundtableEvent>`
    
- `merge` 后按 agentId 分流推送
    
- 每条 agent 流具备：
    
    - `timeout`，`retry`，`circuitBreaker`
        
    - 支持取消，用户打断立刻停止订阅并释放模型连接
        
    - 输出 token 节流与批量推送，降低 WS 帧频率
        

### 2.3 重连补发与一致性

WebSocket 天然不可靠，必须补齐机制。

- Redis 里按 `topicId:agentId` 存最近 N 秒事件列表
    
- 前端重连带 `lastSeq`
    
- 后端从缓存补发缺失事件，再切回实时流
    

### 2.4 成本与质量治理

多智能体会放大成本，必须“可计量”。

- 记录每个 agent 的 token 使用量、耗时、失败原因
    
- 设置 topic 级预算
    
    - 超预算直接降级：减少轮次，减少席位，切便宜模型
        
- 输出质量最小指标
    
    - 是否包含结构化块
        
    - 是否给出可执行行动项
        
    - Round 1 时引用率
        

---

## 3. 我会怎么落地项目结构

### 分层建议

1. `protocol`：事件模型、序列化、版本管理
    
2. `prompt`：Prompt 管理与版本化，支持灰度
    
3. `llm-adapter`：Spring AI 封装，统一输出为 Flux
    
4. `orchestrator`：Round 0 1 2 编排状态机
    
5. `delivery`：WebSocket 推送、补发、节流
    
6. `observability`：metrics tracing logging
    

意义：你后续加互怼与多轮只动 orchestrator，不会污染 delivery 与 adapter。

---

## 4. 当前阶段我给出的执行顺序

1. **定义 RoundtableEvent 协议**，写成代码与文档
    
2. **实现 Round 0 并发流式输出**，补齐 timeout cancel retry
    
3. **实现 WS 推送与 seq**，前后端能稳定渲染
    
4. **加 Redis 补发窗口**，解决断线问题
    
5. **打通观测**，至少有延迟 token 错误率
    
6. 再做 Round 1 互怼与 Round 2 纪要
    

---

## 5. 你现有代码需要立刻调整的点

- `CompletableFuture.runAsync` 改为受控调度器或 Reactor 流，否则线程池失控概率高。
    
- token 推送做节流，建议 30ms 到 80ms 批量发送一次，前端体验更稳，WS 帧数显著下降。
    
- 推送消息加 `topicId seq eventType`，否则无法恢复与回放。
    

---

## 结论

我作为后端负责人会选择 **Spring Boot 3 + WebFlux + Spring AI + WebSocket STOMP + Redis + PostgreSQL + Resilience4j + OpenTelemetry**，并把第一阶段目标锁死在“Round 0 稳定并发流式输出 + 可恢复推送 + 可观测成本”。

如果你希望我继续往下推，我可以直接给出：

- `RoundtableEvent` 的 Java record 定义
    
- WebFlux 编排的伪代码骨架
    
- Redis 补发的数据结构与 key 设计
    
- STOMP 订阅与鉴权的最小实现方案