### 第一步：环境与依赖安装

如果你还没有创建项目：

Bash

```
npm create vue@latest roundtable-frontend
cd roundtable-frontend
npm install
```

安装核心依赖（WebSocket 通信、Markdown 渲染、样式）：

Bash

```
npm install @stomp/stompjs markdown-it
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p
```

_(注意：请确保你的 `tailwind.config.js` 里的 `content` 数组包含了 `['./index.html', './src/**/*.{vue,js,ts,jsx,tsx}']`，这样样式才会生效)_

---

### 第二步：核心逻辑层 (`useRoundtable.js`)

我们在 `src/composables` 下新建此文件。这是前端的“大脑”，负责连接后端、接收流式数据、分发给不同的智能体。

JavaScript

```
// src/composables/useRoundtable.js
import { ref, reactive } from 'vue';
import { Client } from '@stomp/stompjs';

// 初始化 4 个智能体的位置和人设
const initialAgents = [
    { id: 'agent_ceo', name: 'Steve (CEO)', role: '商业战略', avatar: 'https://api.dicebear.com/7.x/avataaars/svg?seed=Felix', content: '', thinking: false },
    { id: 'agent_tech', name: 'Linus (CTO)', role: '技术架构', avatar: 'https://api.dicebear.com/7.x/avataaars/svg?seed=Aneka', content: '', thinking: false },
    { id: 'agent_pm', name: 'Alice (Product)', role: '用户体验', avatar: 'https://api.dicebear.com/7.x/avataaars/svg?seed=Baby', content: '', thinking: false },
    { id: 'agent_cfo', name: 'Buffett (CFO)', role: '财务风控', avatar: 'https://api.dicebear.com/7.x/avataaars/svg?seed=Grandma', content: '', thinking: false },
];

export function useRoundtable() {
    const agents = reactive(initialAgents); // 响应式的智能体列表
    const client = ref(null);
    const isConnected = ref(false);

    const connect = () => {
        client.value = new Client({
            // 注意：如果后端开启了SockJS，地址可能是 ws://localhost:8080/roundtable-ws/websocket
            // 如果只是纯 WebSocket，则是 ws://localhost:8080/roundtable-ws
            brokerURL: 'ws://localhost:8080/roundtable-ws/websocket', 
            onConnect: () => {
                isConnected.value = true;
                console.log('WebSocket 连接成功');
                
                // 订阅广播频道
                client.value.subscribe('/topic/roundtable', (message) => {
                    const payload = JSON.parse(message.body);
                    handleStreamMessage(payload);
                });
            },
            onDisconnect: () => { isConnected.value = false; },
            onWebSocketError: (error) => { console.error('WS Error:', error); }
        });
        client.value.activate();
    };

    // 处理接收到的碎片信息
    const handleStreamMessage = ({ agentId, content, isFinish }) => {
        const target = agents.find(a => a.id === agentId);
        if (!target) return;

        // 如果收到内容，拼接到 content 中，并标记不再“纯思考”
        if (content) {
            target.thinking = false;
            target.content += content;
        }
        
        // 如果结束了，也可以做一些收尾动画处理
        if (isFinish) {
            target.thinking = false;
        }
    };

    // 用户发送议题
    const sendTopic = (topic) => {
        if (!client.value || !client.value.connected) return;

        // 1. 重置所有智能体状态
        agents.forEach(a => {
            a.content = ''; 
            a.thinking = true; // 进入思考状态（显示呼吸灯）
        });

        // 2. 发送给后端
        client.value.publish({
            destination: '/app/startDiscussion',
            body: JSON.stringify({ topic })
        });
    };

    return { agents, isConnected, connect, sendTopic };
}
```

---

### 第三步：智能体卡片组件 (`AgentCard.vue`)

新建 `src/components/AgentCard.vue`。这个组件负责渲染 Markdown 文本，并处理自动滚动。

HTML

```
<template>
  <div 
    class="relative w-[320px] flex flex-col bg-slate-900/80 backdrop-blur-md border border-slate-700 rounded-xl overflow-hidden shadow-2xl transition-all duration-300"
    :class="{ 'ring-2 ring-blue-500/50 shadow-blue-500/20 translate-y-[-5px]': agent.thinking || isStreaming }"
  >
    
    <div class="flex items-center gap-3 p-3 border-b border-slate-700 bg-slate-800/50">
      <div class="relative">
        <img :src="agent.avatar" class="w-10 h-10 rounded-full bg-slate-600 object-cover" />
        <span v-if="agent.thinking" class="absolute -top-1 -right-1 flex h-3 w-3">
            <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-sky-400 opacity-75"></span>
            <span class="relative inline-flex rounded-full h-3 w-3 bg-sky-500"></span>
        </span>
      </div>
      <div>
        <h3 class="text-slate-100 font-bold text-sm">{{ agent.name }}</h3>
        <p class="text-xs text-blue-400">{{ agent.role }}</p>
      </div>
    </div>

    <div 
      ref="contentBox"
      class="flex-1 p-4 h-[200px] overflow-y-auto text-sm text-slate-300 leading-relaxed scroll-smooth custom-scrollbar"
    >
      <div v-if="agent.thinking && !agent.content" class="flex items-center gap-1 text-slate-500 italic mt-4 animate-pulse">
        正在分析局势...
      </div>
      
      <div v-else v-html="renderedMarkdown" class="markdown-body"></div>
      
      <span v-if="isStreaming" class="inline-block w-1.5 h-4 bg-blue-500 ml-1 animate-blink align-middle"></span>
    </div>
  </div>
</template>

<script setup>
import { computed, watch, ref, nextTick } from 'vue';
import MarkdownIt from 'markdown-it';

const props = defineProps(['agent']);
const md = new MarkdownIt({ breaks: true }); // 支持换行
const contentBox = ref(null);

// 判断是否正在流式输出（即：不思考 且 内容不为空，实际逻辑可优化，这里简单判断）
const isStreaming = computed(() => !props.agent.thinking && props.agent.content.length > 0);

const renderedMarkdown = computed(() => {
    return md.render(props.agent.content || '');
});

// 监听内容变化，自动滚动到底部
watch(() => props.agent.content, async () => {
    await nextTick();
    if (contentBox.value) {
        contentBox.value.scrollTop = contentBox.value.scrollHeight;
    }
});
</script>

<style>
/* Markdown 基础样式修正 */
.markdown-body h1, .markdown-body h2 { color: #e2e8f0; font-weight: bold; margin-top: 0.5em; margin-bottom: 0.3em; }
.markdown-body ul { list-style: disc; padding-left: 1.2em; margin-bottom: 0.5em; }
.markdown-body p { margin-bottom: 0.5em; }
.markdown-body code { background: #1e293b; padding: 2px 4px; rounded: 4px; color: #38bdf8; font-family: monospace; }
.markdown-body pre { background: #0f172a; padding: 8px; border-radius: 6px; overflow-x: auto; margin-bottom: 0.5em; }

/* 滚动条美化 */
.custom-scrollbar::-webkit-scrollbar { width: 4px; }
.custom-scrollbar::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }

/* 光标闪烁动画 */
@keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
.animate-blink { animation: blink 1s infinite; }
</style>
```

---

### 第四步：主入口布局 (`App.vue`)

这里我们把卡片摆成一个扇形，把用户放在下面。

HTML

```
<template>
  <div class="min-h-screen bg-[#0b0e14] text-white flex flex-col items-center overflow-hidden relative font-sans">
    
    <div class="absolute inset-0 bg-[linear-gradient(rgba(30,41,59,0.3)_1px,transparent_1px),linear-gradient(90deg,rgba(30,41,59,0.3)_1px,transparent_1px)] bg-[size:40px_40px] z-0 pointer-events-none"></div>

    <header class="z-10 mt-6 text-center">
      <h1 class="text-3xl font-black tracking-[0.2em] text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-purple-500">
        ROUNDTABLE <span class="text-xs tracking-normal text-slate-500 block mt-1">AI ADVISORY BOARD</span>
      </h1>
      <div class="mt-2 text-xs font-mono">
        Status: 
        <span :class="isConnected ? 'text-green-400' : 'text-red-500'">
          {{ isConnected ? '● ONLINE' : '○ CONNECTING...' }}
        </span>
      </div>
    </header>

    <main class="relative flex-1 w-full max-w-5xl flex justify-center mt-10 z-10">
      
      <div class="absolute top-[100px] w-[600px] h-[300px] bg-blue-900/10 rounded-[100%] blur-[60px]"></div>

      <div class="absolute left-10 top-10 transform -rotate-6 hover:rotate-0 transition-transform duration-300 z-20">
        <AgentCard :agent="agents[0]" />
      </div>

      <div class="absolute left-32 bottom-20 transform -rotate-3 hover:rotate-0 transition-transform duration-300 z-30">
        <AgentCard :agent="agents[1]" />
      </div>

      <div class="absolute right-32 bottom-20 transform rotate-3 hover:rotate-0 transition-transform duration-300 z-30">
        <AgentCard :agent="agents[2]" />
      </div>

      <div class="absolute right-10 top-10 transform rotate-6 hover:rotate-0 transition-transform duration-300 z-20">
        <AgentCard :agent="agents[3]" />
      </div>

    </main>

    <footer class="w-full max-w-2xl mb-12 px-4 z-50">
      <div class="relative group">
        <div class="absolute -inset-1 bg-gradient-to-r from-blue-600 to-purple-600 rounded-2xl blur opacity-25 group-hover:opacity-50 transition duration-1000 group-hover:duration-200"></div>
        <div class="relative bg-slate-900 ring-1 ring-slate-700 rounded-2xl p-2 flex gap-3 shadow-2xl">
          <textarea 
            v-model="inputTopic"
            @keydown.enter.prevent="submit"
            placeholder="请输入今日议题 (例如：我们是否应该砍掉移动端项目，全力做 AI？)..." 
            class="w-full bg-transparent text-slate-200 p-3 outline-none resize-none h-[60px] custom-scrollbar placeholder-slate-600"
          ></textarea>
          <button 
            @click="submit"
            :disabled="!inputTopic.trim() || !isConnected"
            class="bg-blue-600 hover:bg-blue-500 disabled:bg-slate-700 text-white font-bold px-6 rounded-xl transition-all active:scale-95 flex flex-col justify-center items-center w-24"
          >
            <span>发起</span>
            <span class="text-[10px] opacity-70">ENTER</span>
          </button>
        </div>
      </div>
    </footer>

  </div>
</template>

<script setup>
import { onMounted, ref } from 'vue';
import { useRoundtable } from './composables/useRoundtable';
import AgentCard from './components/AgentCard.vue';

const { agents, connect, sendTopic, isConnected } = useRoundtable();
const inputTopic = ref('');

onMounted(() => {
  connect();
});

const submit = () => {
  if (!inputTopic.value.trim()) return;
  sendTopic(inputTopic.value);
  // 可选：发送后清空输入框
  // inputTopic.value = ''; 
};
</script>
```